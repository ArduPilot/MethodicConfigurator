name: Windows Installer

on:
  release:
     types: [published]
  workflow_dispatch:
  push:
    paths:
      - '**/*.py'        # Watch for changes in any Python files

concurrency:
  group: ci-${{github.workflow}}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  windows_installer:
    runs-on: 'windows-latest'
    strategy:
      matrix:
        python-version: ['3.12']

    permissions:
      contents: write
      id-token: write    # Needed for keyless signing
      actions: read      # Needed for provenance generation
      packages: write    # Add this permission for attestations
      attestations: write # Add permissions for attestations

    steps:
      # step-security/harden-runner does not (yet) run on windows, so do not use it

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      # https://docs.astral.sh/uv/guides/integration/github/
      - name: Install uv and set the python version
        uses: astral-sh/setup-uv@6b9c6063abd6010835644d4c2e1bef4cf5cd0fca # v6.0.1
        with:
            python-version: ${{ matrix.python-version }}
            activate-environment: true

      - name: Install dependencies
        run: |
          uv pip install .[win_dist]

      - name: Download Inno Setup installer
        run: curl -L -o installer.exe http://files.jrsoftware.org/is/6/innosetup-6.3.3.exe

      - name: Install Inno Setup
        run: ./installer.exe /verysilent /allusers /dir=inst

      - name: List installed software versions
        run: |
          python -m pip list

      - name: Prepare installer
        run: |
          cd ardupilot_methodic_configurator
          copy ..\\windows\\ardupilot_methodic_configurator.spec
          pyinstaller --clean ardupilot_methodic_configurator.spec
          del ardupilot_methodic_configurator.spec

      - name: Write the git commit hash to file
        run: |
          $hash = git rev-parse HEAD
          $hash = $hash.Trim()
          $utf8NoBom = New-Object System.Text.UTF8Encoding $false
          [System.IO.File]::WriteAllText("git_hash.txt", $hash, $utf8NoBom)

      - name: Verify git hash file
        run: |
          Write-Host "Git hash file content:"
          $bytes = [System.IO.File]::ReadAllBytes("git_hash.txt")
          if ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
            Write-Host "::warning::File contains UTF-8 BOM"
          } else {
            Write-Host "File has no BOM (good)"
          }
          Get-Content -Raw git_hash.txt

      - name: Debug GitHub token and permissions
        run: |
          Write-Host "Checking GitHub token and permissions"
          # Don't print the actual token, just check if it exists
          if ([string]::IsNullOrEmpty("${{ secrets.GITHUB_TOKEN }}")) {
            Write-Host "::warning::GITHUB_TOKEN is empty or not accessible"
          } else {
            Write-Host "GITHUB_TOKEN is available"
          }

          # Check if running in fork (which may have limited permissions)
          if ("${{ github.repository }}" -ne "${{ github.repository_owner }}/${{ github.event.repository.name }}") {
            Write-Host "::warning::Running in a fork which may have limited permissions"
          }

      - name: Build installer
        run: |
          cd windows
          $env:VERSION=$(python return_version.py)
          curl -L -o "c:\program files (x86)\inno setup 6\Languages\ChineseSimplified.isl" https://raw.githubusercontent.com/jrsoftware/issrc/refs/heads/main/Files/Languages/Unofficial/ChineseSimplified.isl
          ISCC.exe /dMyAppVersion=$env:VERSION ardupilot_methodic_configurator.iss
          ls Output

      - name: Generate GitHub Actions build provenance
        uses: actions/attest-build-provenance@v2.3.0
        with:
          subject-path: windows/Output/*.exe
          subject-name: 'ardupilot_methodic_configurator'
          push-to-registry: false
          # Use the built-in token instead of secrets
          github-token: ${{ github.token }}
          show-summary: true

      - name: Install Cosign
        uses: sigstore/cosign-installer@3454372f43399081ed03b604cb2d021dabca52bb

      - name: Generate hashes
        id: hash
        run: |
          cd windows/Output
          $files = Get-ChildItem -Filter *.exe | ForEach-Object { $_.Name }
          $hashes = $files | ForEach-Object {
            $hash = (Get-FileHash -Algorithm SHA256 $_).Hash
            $encoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("$($hash)  $_"))
            $encoded
          }
          $hashesJoined = $hashes -join ','
          "hashes=$hashesJoined" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Store Executable Path
        id: exe_path
        run: |
          cd windows/Output
          $exePath = Get-ChildItem -Filter *.exe | Select-Object -First 1 -ExpandProperty FullName
          "exe_path=$exePath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Install SLSA Verifier
        run: |
          $version = "v2.7.0"
          $url = "https://github.com/slsa-framework/slsa-verifier/releases/download/$version/slsa-verifier-windows-amd64.exe"
          Invoke-WebRequest -Uri $url -OutFile "slsa-verifier.exe"

          # Verify the download was successful
          if (Test-Path "slsa-verifier.exe") {
            Write-Host "SLSA verifier downloaded successfully to $(Get-Location)\slsa-verifier.exe"
          } else {
            Write-Host "::error::Failed to download SLSA verifier"
            exit 1
          }

      - name: Generate SLSA provenance
        uses: slsa-framework/slsa-github-generator/actions/generator/generic/create-base64-subjects-from-file@f7dd8c54c2067bafc12ca7a55595d5ee9b75204a # v2.1.0
        id: slsa_provenance
        with:
          path: ${{ steps.exe_path.outputs.exe_path }}

      - name: Extract published SLSA provenance from output
        id: extract_provenance
        run: |
          # According to the documentation, the provenance output should be accessible through the action's outputs
          $artifactName = "${{ steps.slsa_provenance.outputs.artifact-name }}"
          $provenancePath = "${{ steps.slsa_provenance.outputs.metadata-path }}"

          Write-Host "SLSA provenance artifact name: $artifactName"
          Write-Host "SLSA provenance metadata path: $provenancePath"

          # The generator action uploads the provenance as an artifact with a specific name pattern
          # The metadata contains information about where to find the attestation
          if (-not [string]::IsNullOrEmpty($artifactName)) {
            Write-Host "SLSA generator provided artifact name: $artifactName"

            # Look for attestation files with the expected pattern
            $attestationFiles = Get-ChildItem -Path "." -Recurse -Filter "*.intoto.jsonl" -ErrorAction SilentlyContinue |
              Where-Object { $_.Name -like "*$artifactName*" }

            if ($attestationFiles) {
              $provenanceFile = $attestationFiles[0].FullName
              Write-Host "Found provenance file from artifact name: $provenanceFile"
              "provenance_file=$provenanceFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
              exit 0
            }
          }

          # Check if any attestation file was just created by the generator
          $recentFiles = Get-ChildItem -Path "." -Recurse -Filter "*.intoto.jsonl" -ErrorAction SilentlyContinue |
            Where-Object { $_.CreationTime -gt (Get-Date).AddMinutes(-5) } |
            Where-Object {
              $_.FullName -notlike "*\testdata\*" -and
              $_.FullName -notlike "*\test\*" -and
              $_.FullName -notlike "*\_actions\*\testdata\*"
            }

          if ($recentFiles) {
            $provenanceFile = $recentFiles[0].FullName
            Write-Host "Found recently created provenance file: $provenanceFile"
            "provenance_file=$provenanceFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0
          }

          Write-Host "No provenance file found in output, will search for it or create a custom one"
          "provenance_file=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Create custom SLSA provenance file
        if: steps.extract_provenance.outputs.provenance_file == ''
        id: create_provenance
        run: |
          # Create a simple provenance file in the correct format since the SLSA action appears to be failing
          $outputFile = "custom_provenance.intoto.jsonl"

          $exe = Get-Item ${{ steps.exe_path.outputs.exe_path }}
          $hash = (Get-FileHash -Algorithm SHA256 $exe.FullName).Hash.ToLower()

          $exeName = $exe.Name
          $repoInfo = "${{ github.repository }}"
          $refInfo = "${{ github.ref }}"
          $shaInfo = "${{ github.sha }}"
          $actorInfo = "${{ github.actor }}"
          $runId = "${{ github.run_id }}"
          $runAttempt = "${{ github.run_attempt }}"
          $timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"

          # Create the subject portion with proper values substituted
          $subject = @"
            [{"name":"$exeName","digest":{"sha256":"$hash"}}]
          "@

          # Create the payload with actual values
          $payload = @{
            "_type" = "https://in-toto.io/Statement/v0.1"
            "predicateType" = "https://slsa.dev/provenance/v1"
            "subject" = ConvertFrom-Json $subject
            "predicate" = @{
              "builder" = @{
                "id" = "https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@refs/heads/main"
              }
              "buildType" = "https://actions.github.io/buildtypes/workflow/v1"
              "invocation" = @{
                "configSource" = @{
                  "uri" = "git+https://github.com/$repoInfo@$shaInfo"
                  "digest" = @{
                    "sha1" = "$shaInfo"
                  }
                  "entryPoint" = ".github/workflows/windows_build.yml"
                }
                "parameters" = @{}
                "environment" = @{
                  "github_actor" = "$actorInfo"
                  "github_ref" = "$refInfo"
                  "github_sha" = "$shaInfo"
                  "github_workflow" = "windows_build.yml"
                  "github_run_id" = "$runId"
                  "github_run_attempt" = "$runAttempt"
                }
              }
              "metadata" = @{
                "invocationId" = "https://github.com/$repoInfo/actions/runs/$runId/attempts/$runAttempt"
                "timestamp" = "$timestamp"
              }
            }
          }

          # Convert to JSON
          $payloadJson = ConvertTo-Json -InputObject $payload -Depth 10 -Compress

          # Base64 encode the payload
          $payloadBase64 = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($payloadJson))

          # Create full provenance
          $content = @"
          {"payloadType":"application/vnd.in-toto+json","payload":"$payloadBase64","signatures":[]}
          "@

          Set-Content -Path $outputFile -Value $content
          Write-Host "Created custom provenance file at: $(Get-Item $outputFile | Select-Object -ExpandProperty FullName)"
          "provenance_file=$(Get-Item $outputFile | Select-Object -ExpandProperty FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

          # Output the hash for verification
          Write-Host "Executable: $exeName"
          Write-Host "Hash: $hash"

      - name: Save SLSA provenance path
        id: provenance_path
        run: |
          # First check if we already have a provenance file from previous steps
          if (-not [string]::IsNullOrEmpty("${{ steps.extract_provenance.outputs.provenance_file }}")) {
            $provenanceFile = "${{ steps.extract_provenance.outputs.provenance_file }}"
            Write-Host "Using provenance file from SLSA output: $provenanceFile"
            "provenance_file=$provenanceFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0
          }

          if (-not [string]::IsNullOrEmpty("${{ steps.create_provenance.outputs.provenance_file }}")) {
            $provenanceFile = "${{ steps.create_provenance.outputs.provenance_file }}"
            Write-Host "Using custom provenance file: $provenanceFile"
            "provenance_file=$provenanceFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            exit 0
          }

          # Find non-test provenance files
          Write-Host "Searching for non-test provenance files..."
          $provenanceFiles = Get-ChildItem -Path "." -Recurse -Filter "*.intoto.jsonl" -ErrorAction SilentlyContinue |
            Where-Object {
              $_.FullName -notlike "*\testdata\*" -and
              $_.FullName -notlike "*\test\*" -and
              $_.FullName -notlike "*\_actions\*\testdata\*"
            } |
            Select-Object -First 1 -ExpandProperty FullName

          if (-not $provenanceFiles) {
            Write-Host "::warning::SLSA provenance file not found, setting empty path"
            "provenance_file=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          } else {
            $provenanceFile = $provenanceFiles.Replace('/', '\')
            Write-Host "Found provenance file at: $provenanceFile"
            "provenance_file=$provenanceFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          }

      - name: Debug SLSA provenance files
        run: |
          Write-Host "Looking for provenance files..."
          $files = Get-ChildItem -Path ".", "..\..\" -Recurse -Depth 3 -Filter "*.intoto.*" -ErrorAction SilentlyContinue |
            Where-Object {
              $_.FullName -notlike "*\testdata\*" -and
              $_.FullName -notlike "*\test\*" -and
              $_.FullName -notlike "*\_actions\*\testdata\*"
            } |
            Select-Object -ExpandProperty FullName
          Write-Host "Found provenance files (excluding test files):"
          $files | ForEach-Object { Write-Host $_ }

      - name: Verify SLSA Provenance
        continue-on-error: true
        run: |
          # Use the explicitly saved provenance path
          $provenance = "${{ steps.provenance_path.outputs.provenance_file }}"

          if (-not $provenance) {
            Write-Host "::warning::SLSA provenance file path not set, skipping verification"
            exit 0  # Don't fail the build, but warn about it
          }

          # Store current directory for reference
          $currentDir = Get-Location
          Write-Host "Current directory: $currentDir"

          # Check if the verifier exists
          $verifierPath = Join-Path $currentDir "slsa-verifier.exe"
          if (-not (Test-Path $verifierPath)) {
            Write-Host "::warning::SLSA verifier not found at $verifierPath, checking parent directory"
            $verifierPath = Join-Path (Get-Item $currentDir).Parent.FullName "slsa-verifier.exe"

            if (-not (Test-Path $verifierPath)) {
              Write-Host "::warning::SLSA verifier not found at $verifierPath, looking in all parent directories"
              $verifierPath = Get-ChildItem -Path (Get-Item $currentDir).Root.FullName -Recurse -Filter "slsa-verifier.exe" -ErrorAction SilentlyContinue |
                Select-Object -First 1 -ExpandProperty FullName

              if (-not $verifierPath) {
                Write-Host "::error::SLSA verifier not found anywhere, skipping verification"
                exit 0
              }
            }
          }

          Write-Host "Using SLSA verifier at: $verifierPath"

          # Try to get the version to verify it works
          try {
            & $verifierPath --version
            Write-Host "SLSA verifier version check successful"
          } catch {
            Write-Host "::warning::Error running SLSA verifier: $_"
            Write-Host "Will try basic verification instead"
            $useBasicVerification = $true
          }

          if (-not (Test-Path $provenance)) {
            Write-Host "::warning::SLSA provenance file not found at path: $provenance, skipping verification"
            exit 0  # Don't fail the build, but warn about it
          }

          Write-Host "Found provenance file at: $provenance"

          # First display provenance content for debugging
          Write-Host "Provenance content preview:"
          Get-Content -Path $provenance -TotalCount 20

          # Verify provenance for each executable
          cd windows/Output
          Get-ChildItem -Filter *.exe | ForEach-Object {
            Write-Host "Verifying SLSA provenance for $_..."
            $fileHash = (Get-FileHash -Algorithm SHA256 $_.FullName).Hash.ToLower()
            Write-Host "File hash: $fileHash"

            if (-not $useBasicVerification) {
              try {
                # Use the full path to the verifier
                & $verifierPath verify-artifact `
                  --provenance-path "$provenance" `
                  --source-uri "github.com/${{ github.repository }}" `
                  --builder-id "https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@refs/heads/main" `
                  $_.FullName

                if ($LASTEXITCODE -eq 0) {
                  Write-Host "✅ SLSA provenance verified for $_"
                  continue
                }
              } catch {
                Write-Host "::warning::Error running SLSA verification: $_"
              }
            }

            # Fallback to basic verification
            $provenanceContent = Get-Content -Raw $provenance

            # Try exact hash match first
            if ($provenanceContent -match [regex]::Escape($fileHash)) {
              Write-Host "✅ Basic hash verification passed for $_ with exact match"
            } else {
              Write-Host "Exact hash match not found, trying base64 decode..."

              # If base64 encoded, try to decode relevant parts
              if ($provenanceContent -match '"payload":"([^"]+)"') {
                  try {
                      $decodedPayload = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($matches[1]))
                      # Debug output
                      Write-Host "Decoded payload preview:"
                      Write-Host $decodedPayload.Substring(0, [Math]::Min($decodedPayload.Length, 500))

                      if ($decodedPayload -match [regex]::Escape($fileHash)) {
                          Write-Host "✅ Hash found in decoded payload"
                      } else {
                          Write-Host "::warning::Hash verification failed for $_, hash not found in provenance file"
                          Write-Host "This typically means the provenance file does not match the artifact"
                      }
                  } catch {
                      Write-Host "::warning::Failed to decode payload: $_"
                  }
              }
            }
          }

      - name: Sign artifacts
        run: |
          cd windows/Output
          # Sign each installer file with bundle output
          Get-ChildItem -Filter *.exe | ForEach-Object {
            cosign sign-blob --yes --output-signature "$($_.Name).sig" --bundle "$($_.Name).bundle" $_.Name
          }

      - name: Verify signatures
        continue-on-error: true
        run: |
          cd windows/Output
          # Verify each signature
          $verificationSuccess = $true
          Get-ChildItem -Filter *.exe | ForEach-Object {
            Write-Host "Verifying signature for $_..."

            # Check if bundle exists and use it
            if (Test-Path "$($_.Name).bundle") {
              Write-Host "Using bundle verification"
              cosign verify-blob --signature "$($_.Name).sig" --bundle "$($_.Name).bundle" $_.Name `
                --certificate-identity-regexp "https://github.com/${{ github.repository }}/.+" `
                --certificate-oidc-issuer "https://token.actions.githubusercontent.com"

              if ($LASTEXITCODE -eq 0) {
                Write-Host "✅ Signature verified for $_ using bundle"
              } else {
                Write-Host "❌ Bundle verification failed for $_"
                $verificationSuccess = $false
              }
            } else {
              Write-Host "Bundle not found, using keyless verification"
              cosign verify-blob --signature "$($_.Name).sig" $_.Name `
                --certificate-identity-regexp "https://github.com/${{ github.repository }}/.+" `
                --certificate-oidc-issuer "https://token.actions.githubusercontent.com"

              if ($LASTEXITCODE -ne 0) {
                Write-Host "❌ Signature verification failed for $_"
                $verificationSuccess = $false
              } else {
                Write-Host "✅ Signature verified for $_"
              }
            }
          }
          if (-not $verificationSuccess) {
            Write-Host "::error::Signature verification failed for one or more artifacts"
            exit 1
          }

      - name: Upload signatures
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: signatures
          path: |
            windows/Output/*.sig
            *.intoto.jsonl
          retention-days: 7

      - name: Archive build
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
           name: ardupilot_methodic_configurator_setup
           path: windows/Output
           retention-days: 7

      - name: Pre Release
        uses: "rearrangement/auto-releases@e0660c0d60165d4902ebdb4fdcc3c029e94f7215" # v1.1
        if: github.ref == 'refs/heads/master'
        with:
          automatic_release_tag: "latest"
          prerelease: true
          title: "Development Build"
          files: windows/Output/*.*
          repo_token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Release
        uses: "rearrangement/auto-releases@e0660c0d60165d4902ebdb4fdcc3c029e94f7215" # v1.1
        if: startsWith(github.ref, 'refs/tags/v')
        with:
          prerelease: false
          files: windows/Output/*.*
          repo_token: "${{ secrets.GITHUB_TOKEN }}"
